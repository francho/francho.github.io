---
layout: post
title: 'Truco Android: Un solo código, varias aplicaciones'
date: 2010-09-16 17:28:37.000000000 +02:00
categories:
- android
- Portada
tags:
- android
- ant
- automatización
- compilar
- integración continua
- versiones
status: publish
type: post
published: true
meta:
  _edit_last: '2'
  _syntaxhighlighter_encoded: '1'
author:
  login: francho

  display_name: francho
  first_name: ''
  last_name: ''
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p><img class="aligncenter size-full wp-image-727" title="android_compilando_ant" src="/assets/android_compilando_ant.png" alt="android_compilando_ant" width="368" height="300" /><br />
En muchas situaciones necesitamos generar varias aplicaciones a partir de un mismo código fuente. El caso típico es cuando queremos sacar una versión lite, con menos funcionalidades para abrir boca y que los usuarios se animen a comprar la versión pro que es de pago ;)</p>
<p>Una forma de hacerlo es mantener dos proyectos separados pero, a la larga, este sistema acaba volviéndose contra nosotros ya que nos obliga a aplicar los cambios por duplicado.</p>
<p>Buscando una forma de simplificar esta tarea rutinaria me topé con este a <a href="http://blog.elsdoerfer.name/2010/04/29/android-build-multiple-versions-of-a-project/">artículo</a> que me puso sobre la pista:</p>
<p>La idea es hacer un único proyecto que contenga toda la funcionalidad y luego usar <a href="http://ant.apache.org/">Ant</a> para compilarlo y generar las dos versiones (lite y pro).</p>
<p>Con unos mínimos cambios en el código y un pequeño script conseguí automatizar totalmente la generación de los "sabores" de mi aplicación.</p>
<p>Estos son los pasos a realizar....<br />
<!--more--><br />
<strong>1º organización de código</strong></p>
<p>Hay que reescribir el código para que, cuando necesite activar o desactivar funcionalidades dependientes de la versión, haga uso de una la clase Application que contiene un método (por ejemplo isLite() ). Este método consulta el nombre de paquete de la aplicación para determinar la aplicación que está corriendo:</p>
<p>{% highlight java %}<br />
public class MiappApplication extends Application {<br />
	public boolean isLite() {<br />
		return getApplicationContext().getPackageName().equals(&quot;org.francho.miapp.lite&quot;);<br />
	}<br />
}<br />
{% endhighlight %}</p>
<p>Se mueven todas las Activity a un subpaquete ( org.francho.miapp.activities ) de esta forma nos obligamos aimport de la clase R en cada una de ellas para evitar que su referencia sea ambigua.</p>
<p>En los casos necesarios se crean nuevas layouts (más limitadas) para la versión lite. Por supuesto, el setContentView() de las actividades que las usan va dentro de una condición que llama al método isLite() antes mencionado. Además hay que asegurarse de que el código no fallará en ninguna de las dos versiones (por ejemplo con NullPointerException)</p>
<p><strong>2º Configurar ANT para crear la versión Lite</strong></p>
<p>Siguiendo las instrucciones del <a href="http://developer.android.com/guide/developing/other-ide.html">manual de Android (capítulo desarrollando con otros IDE)</a> se genera un proyecto temporal vacío:</p>
<ol>
<li>Si no lo tenemos ya, añadimos la ruta de las herramientas Android a nuestro path: {% highlight bash %}export PATH=$PATH:/opt/android-sdk-linux_86/tools/{% endhighlight %}</li>
<li>Creamos un proyecto temporal  {% highlight bash %}android create project --target 8 --name dummyname --package dummy.package --activity DummyActivity --path ./dummy_project{% endhighlight %}</li>
</ol>
<p>Esto nos crea toda la estructura del proyecto y los scripts necesarios para compilarlo usando ant, esos son los que queremos. Así que los copiamos a una nueva carpeta (luego podemos borrar el proyecto temporal):</p>
<p>{% highlight bash %}<br />
$ mkdir miapp_lite_ant<br />
$ cp dummy_project/build.* miapp_lite_ant/<br />
$ cp dummy_project/default.properties  miapp_lite_ant/<br />
$ cp dummy_project/local.properties  miapp_lite_ant/<br />
{% endhighlight %}</p>
<p>Editamos <strong>build.xml</strong> y añadimos al final (después del setup) nuestras reglas personalizadas, en nuestro caso hemos añadido unas que antes de generar el fichero de recursos R cambia el nombre del paquete de la aplicación principal por el de la aplicación secundaria. De esta forma las referencias a la clase R no fallarán. También cambian el nombre del paquete en el AndroidManifest (si no tienen paquetes diferentes no podremos subirlas al Market de forma simultánea):</p>
<p>{% highlight xml %}<br />
    &lt;!-- Generates the R.java file for this project's resources. --&gt;<br />
    &lt;target name=&quot;-resource-src&quot; depends=&quot;-dirs&quot;&gt;<br />
        &lt;echo&gt;Generating R.java / Manifest.java from the resources...&lt;/echo&gt;</p>
<p>        &lt;!-- francho --&gt;<br />
        &lt;replace dir=&quot;src&quot; includes=&quot;**/*.java&quot; &gt;<br />
                &lt;replacetoken&gt;&lt;![CDATA[import org.francho.miapp.R]]&gt;&lt;/replacetoken&gt;<br />
                &lt;replacevalue&gt;&lt;![CDATA[import org.francho.miapp.lite.R]]&gt;&lt;/replacevalue&gt;<br />
        &lt;/replace&gt;</p>
<p>        &lt;replace file=&quot;AndroidManifest.xml&quot;&gt;<br />
                &lt;replacetoken&gt;&lt;![CDATA[package=&quot;org.francho.miapp&quot;]]&gt;&lt;/replacetoken&gt;<br />
                &lt;replacevalue&gt;&lt;![CDATA[package=&quot;org.francho.miapp.lite&quot;]]&gt;&lt;/replacevalue&gt;<br />
        &lt;/replace&gt;</p>
<p>        &lt;!-- --&gt;</p>
<p>        &lt;exec executable=&quot;${aapt}&quot; failonerror=&quot;true&quot;&gt;<br />
            &lt;arg value=&quot;package&quot; /&gt;<br />
            &lt;arg line=&quot;${v.option}&quot; /&gt;<br />
            &lt;arg value=&quot;-m&quot; /&gt;<br />
            &lt;arg value=&quot;-J&quot; /&gt;<br />
            &lt;arg path=&quot;${gen.absolute.dir}&quot; /&gt;<br />
            &lt;arg value=&quot;-M&quot; /&gt;<br />
            &lt;arg path=&quot;AndroidManifest.xml&quot; /&gt;<br />
            &lt;arg value=&quot;-S&quot; /&gt;<br />
            &lt;arg path=&quot;${resource.absolute.dir}&quot; /&gt;<br />
            &lt;arg value=&quot;-I&quot; /&gt;<br />
            &lt;arg path=&quot;${android.jar}&quot; /&gt;</p>
<p>        &lt;/exec&gt;</p>
<p>    &lt;/target&gt;<br />
{% endhighlight %}</p>
<p>El fichero build.xml se puede personalizar al gusto, por ejemplo para que use un icono o un nombre diferente por cada aplicación bastaría añadir nuevas reglas similares a las anteriores.</p>
<p>Si no queremos teclear la contraseña de la firma cada vez que generemos la aplicación podemos editar el fichero <strong>build.properties</strong> y colocar los datos de nuestro almacen de claves :</p>
  {% highlight xml %}
key.store=../../mi.keystore<br />
key.alias=misclaves<br />
key.store.password=123456<br />
key.alias.password=123456<br />
{% endhighlight %}</p>
<p><strong>3º Generando la aplicación Lite</strong></p>
<p>Una vez que hemos generado todo el código y hemos compilado y probado nuestra aplicación completa (versión gold) con el Eclipse vamos a generar la versión lite.</p>
<p>Para ello tenemos que copiar el código fuente, copiar la configuración de Ant y luego llamar al comando Ant correspondiente:</p>
<p>{% highlight bash %}<br />
$ cp -rf ./miapp_gold/ ./miapp_lite/<br />
$ cp -rf ./miapp_lite_ant/*  ./miapp_lite/<br />
$ cd ./miapp_lite/<br />
{% endhighlight %}</p>
<p>Limpiamos el rastro que haya podido dejar la compilación de la Gold</p>
<p>{% highlight bash %}<br />
$ ant clean<br />
{% endhighlight %}</p>
<p>Generamos una versión de debug y la probamos (la instalará en el dispositivo por defecto conectado)</p>
<p>{% highlight bash %}<br />
$ ant install<br />
{% endhighlight %}</p>
<p>Cuando hemos comprobado que todo va ok, generamos la release. Ant se encarga de compilar, firmar y aplicar el zipalign.</p>
<p>{% highlight bash %}<br />
$ ant release<br />
{% endhighlight %}</p>
<p>Ya solo nos queda subir nuestro flamante apk al Android Market y ver crecer el numero de descargas ;-)</p>
